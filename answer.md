### Java基础
- #### HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化?
   答: JDK1.7 中，HashMap是数组+链表的方式实现的，链表当中的每一个元素是一个Node，Node保存有key值，value值，已经上一个node和下一个node，当放入元素的时候，通过计算Key的Hash值，决定要放入链表数组的位置，如果数组的当前位置的元素为空值，则会新建一个Node直接放入数组的当前位置，如果不为空，就会遍历链表，如果发现当前的key值等于链表中某一个元素的Key，则改写value值，如果没有key值相等，则直到找到链表的最后一个元素，并且把当前新增的元素新建一个node作为最后一个元素，把Node的prev指向之前的最后一个元素，完成放入操作。移除则也是通过计算hash找到key所在的数组中的位置，遍历列表进行移除。JDK1.8中使用了链表+数组+树的实现，默认有一个阈值，当放入的时候会判定当前链表的长度，如果长度大于了HashMap中设置的链表长度的阈值，则会把链表转为树。<br/>
    <font color='red'>补充</font>: 关于HashMap的tableSizeFor方法，首先会将初始的Capacity的二进制取得从高位到地位的连续的0的个数n，然后将-1右移动n位，则计算出来的值必然是一个奇数。这样满足了容量必须位2的n次方。<br/>
- #### HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小?    
    如果当前的数组长度为0，即使用HashMap的无参构造函数，则会使用默认的初始化容量(16) 和 默认的阈值(16 * 0.8)。<br/>
    &nbsp;&nbsp;如果是已经有元素了则会判断当前的数组长度，如果大最大的数组长度(1<<30)则容量不变，阈值Integer.MAX_VALUE.
    &nbsp;&nbsp;如果不大于最大值，则新的容量大小为oldCap << 1 即 2扩大2倍扩容.
    为什么都是2的N次方幂？当有元素要放入数组的时候，会通过[(cap-1) & hash]的方式计算此元素要放入的位置，并且用奇数 & 的一个任意数,结果是连续的不会产生内存浪费。
- #### HashMap,HashTable,ConcurrentHashMap的区别？
   HashMap，HashMap是实现的AbstractMap，HashMap允许使用键和值为空，没有使用任何的加锁策略，在多线程产生了竞争的话会出现线程安全问题。
   HashTable是继承的Dictionary,HashTable不能用null值作为键或者值。是通过对方法使用synchronized关键字进行了同步，所以是线程安全的类。
   ConcurrenthashMap 也是一个线程安全的HashMap，只不过用的加锁方式由方法，编程了分段加锁，即当你想要放入一个元素的时候，通过[Hash & (cap-1)]的方式计算出下标之后，会加锁当前这一段的链表或者树，进行操作，所以在效率上要比锁整个链表数组的HashTable要高。
- #### java中国呢四种修饰符的限制范围.
   protect,public,private,default
   protect 本类以及子类，本包以是可以访问的。
   public  任意类，任意包可以访问。
   private  只能有本类访问。
   defalut  当前类和同包可以访问。
- #### 动态代理的两种方式，以及区别。
   JDK的动态代理，和CGLIB
   JDK的动态代理需要提供接口，实现InvokeHandle。
   CGLIB的动态代理不需要提供接口，可以直接代理类，实现MethodInterceptor.
- #### Java的序列化方式。
  Serializable 接口
- #### Java中参数的传递方式。
  基本类型是传值。
  如果是对象作为参数，则是把对象的内存地址拷贝一份，作为参数传入。

- #### JVM的内存结构。
  JVM内存结构由程序计数器，方法区(MetaSpace)，堆，Java虚拟机栈,本地方法栈，运行时常量池。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>程序计数器</b>是记录当前线程执行字节码的行号，每一个执行的线程都有一个程序计数器，各个线程计数器互不影响，他们是线程私有的内存。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>方法区</b>用来存储已经加载的类的信息，常量，静态变量，以及即时编译器编译的代码数据。是各个线程共享的区域，在JDK1.8以后，方法区已经被移除，使用MetaSpace代替,MetaSpace使用的是本地内存，所以会减少OOM的风险。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>堆</b>是由JVM管理的最大的一块内存区域，也是内存回收的主要区域，几乎所有的实例对象都是存放在堆区，也是被线程共享的一块区域，如果详细划分，堆又分为Eden，From Survivor,To Survivor.从线程分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>Java虚拟机栈</b>和程序计数器一样，都是线程私有的，他们是随着线程生，随着线程死，用于存储局部变量，操作数栈，动态连接，方法出口等等。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>本地方法栈</b>与Java虚拟机栈提供的功能类似，只是本地方法栈服务队的对象是Native方法，如果栈请求的深度大于虚拟机所允许的最大栈深度则会抛出StackOverFlow异常，如果虚拟机允许动态扩展栈内存，但是当扩展是无法申请到足够的内存的时候会抛出OutOfMemoryException。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<b style='color:red'>运行时常量池</b>原本是方法区的一部分，用于存放编译期间生成的各种字面量符号引用。但是在1.7之后，常量池不会在方法区进行分配了，而是移动到了堆中。<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<font color='red'>直接内存</font>并不是虚拟机运行时数据的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分被频繁的使用，也又可能出现OOM。
- #### GC的常常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop The world，CMS会不会产生碎片，G1的优势。
  谈轮到GC，首先要知道如何知道哪些内存应该被回收？
  如何知道哪些内存需要回收呢？垃圾收集器在进行回收之前会先对对象进行分析，看一个对象是否是或者还是死亡，一般有两种方式，一是引用计数，给对象添加一个引用计数器，当对象被引用的时候引用计数器+1，当引用失效的时候引用计数器就-1，任何时刻，当引用计数器的值为0的时候，就判定此时对象无用了，可以进行回收了，但是引用计数器不能很好的解决循环引用的问题。二是可达性分析，这个算法的基本原理就是通过一系列的GC Root的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何的引用链相连的时候，就可以判定这个对象为可回收对象，一般可以作为GC Roots的对象包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中Native方法引用的对象。目前主流的Java虚拟机都是使用的可达性分析，进行垃圾回收前的分析。当然，并不是被判了死刑就意味着对象就一定会被回收，因为JVM虚拟机还给了对象最后一次申诉的机会，finalize，如果对象实现了finalize方法，那么会被放入一个叫FQUEUE的队列，稍后JVM会启动一个低优先级的线程去执行这些个方法，但是不保证一定会执行完成，只要在finalize中重新将该对象与引用链上的任意对象关联，那么就不会被判死刑。<br/>
  现在已经知道了哪些内存需要回收了，接下来是不是就该进行内存回收了？先了解一下常见的内存清理算法。
  1. 标记-清除算法：算法如名，就是分为标记，清除两个阶段，就是在进行可达性分析的时候标记出哪些对象需要清理，标记完成后呢，标记完成后统一清理已经被标记的对象,他有2个不足：一是标记和清除的效率都不高，另一个是清除之后会产生大量的内存碎片。
  2. 复制算法: 复制算法需要分配两块内存，当一块内存满了之后，满的内存中存活的对象复制到另一块内存中去，然后一次性清理那块已经满了的内存区域，所以他是空间换效率的一种算法。
  3. 标记-整理算法：标记整理算法其实与标记清除算法比较相似，只是在标记之后不是立即进行清除，而是把存活的对象都移动到一端，然后把边界外的对象清理了。
  4. 分代收集算法：将要回收的内存区域分为多个，一般是把堆分为新生代，和老年代，然后根据各个内存区域的特点选用合适的算法。<br/>
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了垃圾回收算法，就应该有垃圾回收器了吧，目前HostSpot所包含的垃圾收集器有：Serial,ParNew,Parallel Scavenge,CMS(Concurrent Mark Sweep),Serial Old,ParOld,Paralle Old,G1,以及JDK11中出现的ZGC收集器。其中，Serial,ParNew,Parallel Scavenge是对新生代进行回收的算法，CMS,ParOld,Paralle Old,是对老年代进行回收的算法。其中Serial算法采用的是单线程，对于新生代使用的是复制算法，会暂停所有用户线程，老年代是使用的标记-整理算法。由于是单线程，整个垃圾回收期间用户的线程都是不可用的状态，所以导致Stop The World的时间会非常长，用户体验会相当的不好。ParNew收集器，是Serial的多线程版本。Parallel Scavenge 收集器，是一个新生代的收集器，它也是使用的复制算法，他的关注点是达到一个可控的吞吐量。</p>


   