# Java高频考点

## Java基础部分

- ### HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化?
  
   答: *JDK1.7中*，HashMap是数组+链表的方式实现的，链表当中的每一个元素是一个Node，Node保存有key值，value值，已经上一个node和下一个node，当放入元素的时候，通过计算Key的Hash值，决定要放入链表数组的位置，如果数组的当前位置的元素为空值，则会新建一个Node直接放入数组的当前位置，如果不为空，就会遍历链表，如果发现当前的key值等于链表中某一个元素的Key，则改写value值，如果没有key值相等，则直到找到链表的最后一个元素，并且把当前新增的元素新建一个node作为最后一个元素，把Node的prev指向之前的最后一个元素，完成放入操作。移除则也是通过计算hash找到key所在的数组中的位置，遍历列表进行移除。JDK1.8中使用了链表+数组+树的实现，默认有一个阈值，当放入的时候会判定当前链表的长度，如果长度大于了HashMap中设置的链表长度的阈值，则会把链表转为树。
   ***

   **$\color{#FF0000}{补充}$: 关于HashMap的tableSizeFor方法，首先会将初始的Capacity的二进制取得从高位到地位的连续的0的个数n，然后将-1右移动n位，则计算出来的值必然是一个奇数。这样满足了容量必须位2的n次方**  

- ### HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小
  
    如果当前的数组长度为0，即使用HashMap的无参构造函数，则会使用默认的初始化容量(16) 和 默认的阈值(16 * 0.8)。  

    &nbsp;&nbsp;如果是已经有元素了则会判断当前的数组长度，如果大最大的数组长度(1<<30)则容量不变，阈值Integer.MAX_VALUE.
    &nbsp;&nbsp;如果不大于最大值，则新的容量大小为oldCap << 1 即 2扩大2倍扩容.
    为什么都是2的N次方幂？当有元素要放入数组的时候，会通过[(cap-1) & hash]的方式计算此元素要放入的位置，并且用奇数 & 的一个任意数,结果是连续的不会产生内存浪费。

- ### HashMap,HashTable,ConcurrentHashMap的区别

   HashMap，HashMap是实现的AbstractMap，HashMap允许使用键和值为空，没有使用任何的加锁策略，在多线程产生了竞争的话会出现线程安全问题。
   HashTable是继承的Dictionary,HashTable不能用null值作为键或者值。是通过对方法使用synchronized关键字进行了同步，所以是线程安全的类。
   ConcurrenthashMap 也是一个线程安全的HashMap，只不过用的加锁方式由方法，编程了分段加锁，即当你想要放入一个元素的时候，通过[Hash & (cap-1)]的方式计算出下标之后，会加锁当前这一段的链表或者树，进行操作，所以在效率上要比锁整个链表数组的HashTable要高。

- ### java中国呢四种修饰符的限制范围

   protect,public,private,default
   protect 本类以及子类，本包以是可以访问的。
   public  任意类，任意包可以访问。
   private  只能有本类访问。
   defalut  当前类和同包可以访问。

- ### 动态代理的两种方式，以及区别

   JDK的动态代理，和CGLIB
   JDK的动态代理需要提供接口，实现InvokeHandle。
   CGLIB的动态代理不需要提供接口，可以直接代理类，实现MethodInterceptor.

- ### Java的序列化方式

  Serializable 接口

- ### Java中参数的传递方式

  基本类型是传值。
  如果是对象作为参数，则是把对象的内存地址拷贝一份，作为参数传入。

- ## JVM部分
  
- ### JVM的内存结构
  
  JVM内存结构由程序计数器，方法区(MetaSpace)，堆，Java虚拟机栈,本地方法栈，运行时常量池.  

   $\color{#FF0000}程序计数器:$是记录当前线程执行字节码的行号，每一个执行的线程都有一个程序计数器，各个线程计数器互不影响，他们是线程私有的内存。

  $\color{#FF0000}{方法区:}$用来存储已经加载的类的信息，常量，静态变量，以及即时编译器编译的代码数据。是各个线程共享的区域，在JDK1.8以后，方法区已经被移除，使用MetaSpace代替,MetaSpace使用的是本地内存，所以会减少OOM的风险。

  $\color{#FF0000}{堆:}$是由JVM管理的最大的一块内存区域，也是内存回收的主要区域，几乎所有的实例对象都是存放在堆区，也是被线程共享的一块区域，如果详细划分，堆又分为Eden，From Survivor,To Survivor.从线程分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。

  $\color{#FF0000}{Java虚拟机栈:}$和程序计数器一样，都是线程私有的，他们是随着线程生，随着线程死，用于存储局部变量，操作数栈，动态连接，方法出口等等。

  $\color{#FF0000}{本地方法栈:}$与Java虚拟机栈提供的功能类似，只是本地方法栈服务队的对象是Native方法，如果栈请求的深度大于虚拟机所允许的最大栈深度则会抛出StackOverFlow异常，如果虚拟机允许动态扩展栈内存，但是当扩展是无法申请到足够的内存的时候会抛出OutOfMemoryException。

  $\color{#FF0000}{运行时常量池:}$原本是方法区的一部分，用于存放编译期间生成的各种字面量符号引用。但是在1.7之后，常量池不会在方法区进行分配了，而是移动到了堆中。

  $\color{#FF0000}{直接内存:}$并不是虚拟机运行时数据的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分被频繁的使用，也又可能出现OOM。

- ### GC的常常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop The world，CMS会不会产生碎片，G1的优势

  谈轮到GC，首先要知道如何知道哪些内存应该被回收？
  如何知道哪些内存需要回收呢？垃圾收集器在进行回收之前会先对对象进行分析，看一个对象是否是或者还是死亡，一般有两种方式，一是引用计数，给对象添加一个引用计数器，当对象被引用的时候引用计数器+1，当引用失效的时候引用计数器就-1，任何时刻，当引用计数器的值为0的时候，就判定此时对象无用了，可以进行回收了，但是引用计数器不能很好的解决循环引用的问题。二是可达性分析，这个算法的基本原理就是通过一系列的GC Root的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何的引用链相连的时候，就可以判定这个对象为可回收对象，一般可以作为GC Roots的对象包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中Native方法引用的对象。目前主流的Java虚拟机都是使用的可达性分析，进行垃圾回收前的分析。当然，并不是被判了死刑就意味着对象就一定会被回收，因为JVM虚拟机还给了对象最后一次申诉的机会，finalize，如果对象实现了finalize方法，那么会被放入一个叫FQUEUE的队列，稍后JVM会启动一个低优先级的线程去执行这些个方法，但是不保证一定会执行完成，只要在finalize中重新将该对象与引用链上的任意对象关联，那么就不会被判死刑。

  现在已经知道了哪些内存需要回收了，接下来是不是就该进行内存回收了？先了解一下常见的内存清理算法。
  1. 标记-清除算法：算法如名，就是分为标记，清除两个阶段，就是在进行可达性分析的时候标记出哪些对象需要清理，标记完成后呢，标记完成后统一清理已经被标记的对象,他有2个不足：一是标记和清除的效率都不高，另一个是清除之后会产生大量的内存碎片。
  2. 复制算法: 复制算法需要分配两块内存，当一块内存满了之后，满的内存中存活的对象复制到另一块内存中去，然后一次性清理那块已经满了的内存区域，所以他是空间换效率的一种算法。
  3. 标记-整理算法：标记整理算法其实与标记清除算法比较相似，只是在标记之后不是立即进行清除，而是把存活的对象都移动到一端，然后把边界外的对象清理了。
  4. 分代收集算法：将要回收的内存区域分为多个，一般是把堆分为新生代，和老年代，然后根据各个内存区域的特点选用合适的算法。

  有了垃圾回收算法，就应该有垃圾回收器了吧，目前HostSpot所包含的垃圾收集器有：Serial,ParNew,Parallel Scavenge,CMS(Concurrent Mark Sweep),Serial Old,ParOld,Paralle Old,G1,以及JDK11中的ZGC收集器。其中，Serial,ParNew,Parallel Scavenge是对新生代进行回收的算法，CMS,ParOld,Paralle Old,是对老年代进行回收的算法。其中Serial算法采用的是单线程，对于新生代使用的是复制算法，会暂停所有用户线程，老年代是使用的标记-整理算法。由于是单线程，整个垃圾回收期间用户的线程都是不可用的状态，所以导致Stop The World的时间会非常长，用户体验会相当的不好。ParNew收集器，是Serial的多线程版本。Parallel Scavenge 收集器，是一个新生代的收集器，它也是使用的复制算法，他的关注点是达到一个可控的吞吐量,在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge 和 Parelle Old收集器。
  
  CMS收集器是一种以获取最短回收时间为目标的收集器。CMS是基于标记-清除算法的实现，他的内存清理需要经历4个阶段:初始标记，并发标记，重新标记，并发清除。初始标记阶段会Stop The World，但由于只是仅仅标记GC Roots能够直接关联的对象，所以速度很快，Stop The World 时间会比较短。接着是并发标记，并发标记就是通过GC Roots 搜索引用链的过程，此时，用户线程和标记线程交替执行。然后再是重新标记，重新标记的目的是为了修正在并发标记阶段因用户线程运行产生的变动，此过程也会Stop The World，
  最后执行并发清理。
  由于CMS是基于标记-清除算法的，那么在回收之后会产生内存碎片，如果新分配的对象无法申请到足够的内存，则会触发Full GC。

  G1收集器将java堆分为多个大小相等的独立区域(Region)，并且Region在物理上不需要连续，逻辑上连续，虽然还保留着新生代和老年代的的概念，但他们只是一部分Region的集合。由于G1存在多个独立区域，则有可能出现一个Region的引用在另一个Region中，所以G1中，每个Region都会有与之对应的RememberSet，虚拟机发现程序在对Reference类型的数据进行写操作的时候，会产生一个WriteBarrier 暂时中断写操作，检查Reference是否处在不同的Region中，如果是，则会通过CardTable把相关引用信息记录到被引用对象所属Region的RememberSet中。  
  
  G1收集器的特点:  
   * 并行与并发，充分利用多个CPU，多核环境下硬件优势，缩短Stop-The-World的时间。
   * 分代收集
   * 空间整合,不会产生空间碎片
   * 可预测的停顿，能让使用者指定一个长度为M毫秒内，消耗在垃圾回收上的时间不超过N毫秒。

  G1收集器的运作大致可划分为以下几个步骤：  
  * 初始标记 (Initial Marking)
  * 并发标记 (Concurrent Marking)
  * 最终标记 (Final Marking)
  * 筛选回收 (Live Data Counting Evacation)  

- ### eden survivor区的比例，为什么是这个比例，eden survivor的工作过程  
  
   默认情况下eden：survivor=8:1，即eden分区占8，From Survivor和To Survivor 各占1 ，因为在大多数情况下对象对象都是在eden区创建，当空间不足的时候会发起一起MinorGC。  
   如果在eden区经历过一次Minor GC的对象仍然存活，则会被移入suvivor区，并且设置对象年龄为1，对象在SUrvivor区活过一次MinorGC年龄就会增加一次，当到达MaxTenuringThreshold设置的值之后，对象会被移如老年代。但是JVM并不是永远要求对象的年龄到达指定的阈值，当在survivor区中同年龄存活的对象超过总容量的一般，则对象被移入到老年代。

- ### Java是否可以GC直接内存
  
  直接内存本身不受GC影响，但是由于对象在堆中有引用这块内存，会受到gc的间接影响。

- ## 虚拟机执行子系统

- ### Java类加载过程  
  
  总体流程:$\color{green}{加载>验证>准备>解析>初始化}$,**加载**是指通过一个类的全额限定名获取该类的二进制字节流，然后将这个字节留所代表的静态数据结构转化为方法区(MetaSpace)的运行时数据结构，再在内存中生成一个代表这个类的Class对象，作为这个类的访问入口。**验证**是对已经加载的类的数据结构进行校验，包括文件格式校验，元数据验证，字节码验证，符号引用验证。**准备**阶段是正式为类分配内存并设置类变量初始值的阶段，这里分配内存仅包括static修饰的类变量，设置初始值是设置类型的0值，而不是对象定义中的初始值。**解析**是将常量池中的符号引用替换为直接引用的过程，**初始化**阶段是按照对象定义的变量值去初始化变量和其他资源，也就是执行&lt;clinit&gt;()方法，此方法是由编译器收集类变量的赋值和static{}修饰的语句块的合并。

- ### 双亲委派模型的过程以及优势
  
  双亲委派模型的工作过程：如果一个类加载器收到了类加载请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器进行加载，每一个层次的类加载器都是如此，因此所有的类加载请求都最终应该传送到顶层类加载器，只有当父类加载器无法完成加载请求的时候，子加载器才会尝试去自己加载。  
  双亲委派模型的优势：Java类随着它的类加载器一起具有优先级的层次关系。